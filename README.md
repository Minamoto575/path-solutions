# 代码结构


源码见`src`

`PathData`是路径数据，包括顶点、路径、临界矩阵等。

`UF`是并查集的实现类。

`FGraph`封装了Floyd算法、相关展示函数。

`Solution1-4`对应了`问题1-4`的解答。

`IMAGES`下是运行结果


# 问题1

本质是判断8个点是否联通，构成的图是否是连通图，可以采用DFS、BFS、并查集。推荐使用并查集。

# 问题2

图论中，常见的求最短距离算法有Dijkstra和Floyd。

可以使用Dijkstra算法，但是一次运算，只能求出这某个点，到其他所有点的最短距离。

如果希望一次运算，求出任意两点的最短距离，可以采用Floyd，题目的意思就是任意两点。

# 问题3

旅行商问题，只是不会回到原点，数据量很小，可以采用DFS回溯。

# 问题4

试想一下，我们希望增加怎样的航线。这里我们假设，航线都是直线，实际上航班也确定都是类直线。

比如1->8没有直达，但是存在两条1->8的线路，他们是13578，12468，这种存在很多中转站的线路，我们希望能够增加直达线，这样我就不需要中转了。

上面是从中转站数量的角度，我们也可以从多增加的距离考虑，存在一种情况 12468，在一条直线上，虽然中转站很多，但是他的距离并没有增加，相对于直接1->8而言。很遗憾，点没有给出坐标，所以这方面我们也无从下手。虽然我们能知道少量信息，比如1->2是300km，2->3是400km，那么1->3我们就可以推断是500km。这些可以写在论文里，我们就不做实现了。

所以现在很清晰，我们列出任意两点之间的最短距离和对应路径，如果某条路径的中转站过多，我们就建议新增直达。这一想法，可以使用变式的Floyd算法，在求解任意两点最短距离的同时，记录下他们的路径。

# 最后

不建议使用A star、蚁群算法、遗传算法，这些演化算法不一定能求出最优解，一般是针对大规模问题会用到，而且相对来说比较复杂、需要调参。

